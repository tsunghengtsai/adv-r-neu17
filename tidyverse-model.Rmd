---
title: "Tidyverse - modeling"
author: "Advanced R"
date: "Thursday May 4, 2017"
output: html_document
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```


## Learning goal

Consistent workflow for both data wrangling and statistical modeling in the tidyverse.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
load("data/adv-R-twin.RData")
```


## Task

Model-based summary of feature log-intensities for all proteins in every run.

* Model the log-intensities of features for each protein considering feature and run as fixed effects.

* Run-level summarization with the fitted model.


## Approaches

We will discuss tools to perform modeling/testing in multiple groups through the use of: 

* Iterations.

* List-columns.


## Normalization

Same as in the previous section:

```{r}
twin_dia <- tbl_df(twin_dia) %>% 
    mutate(
        log2inty_h = log2(intensity_h), 
        log2inty_l = log2(intensity_l)
    )

med_dia <- twin_dia %>% 
    group_by(run) %>% 
    summarise(log2inty_med = median(log2inty_h, na.rm = TRUE)) %>% 
    mutate(log2inty_adj = median(log2inty_med) - log2inty_med)

twin_dia2 <- left_join(twin_dia, med_dia) %>% 
    mutate(
        log2inty_h = log2inty_h + log2inty_adj, 
        log2inty_l = log2inty_l + log2inty_adj, 
        intensity_h = 2 ^ log2inty_h,
        intensity_l = 2 ^ log2inty_l
    )

twin_dia2
```


## Use linear model to summarize feature log-intensities of a protein

Model feature log-intensities with fixed effects of run and feature:

```{r}
# One protein (AACT) measured in 3 runs (R001, R002, R003)
sub_dia <- twin_dia2 %>% 
    filter(protein == "AACT", run %in% c("R001", "R002", "R003"))

# Linear model with fixed effects of run and feature, no intercept
fit <- lm(log2inty_l ~ 0 + run + feature, data = sub_dia)
```


### Extract run effect from the fitted model

```{r}
summary(fit)
```

```{r, eval=FALSE}
str(summary(fit))
```

```{r}
coef(fit)
coef(summary(fit))
```

```{r}
fit_coef <- coef(fit)

data_frame(effect = names(fit_coef), estimate = fit_coef) %>% 
    filter(grepl("run", effect)) %>% 
    mutate(effect = gsub("run", "", effect))
```


## Summarization for all proteins with a `for()` loop


### Approach 1

* Loop over proteins.

* Fit a linear model for each protein with `lm()` and extract fitted parameters with `coef()`.

* Add new results to previous ones in every iteration with `rbind()`.

```{r}
# Proteins in the dataset
prots <- unique(twin_dia2$protein)

# Approach 1
t_start <- proc.time()
df_allprot <- NULL

for (i in seq_along(prots)) {
    oneprot <- twin_dia2 %>% filter(protein == prots[i])  # Subset for one protein
    fit <- lm(log2inty_l ~ 0 + run + feature, data = oneprot)  # Fit a linear model
    fit_coef <- coef(fit)  # Extract fitted parameters
    # Assemble the result in a data frame, and combine with those in previous iterations
    df_oneprot <- data_frame(
        protein = prots[i], 
        effect = names(fit_coef), 
        estimate = fit_coef
    ) %>% 
        filter(grepl("run", effect)) %>% 
        mutate(effect = gsub("run", "", effect))
    df_allprot <- rbind(df_allprot, df_oneprot)
}
(t1 <- proc.time() - t_start)
```

We should avoid this approach as it's not very efficient - in every iteration, R has to copy all the data from previous iterations.


### Approach 2

* Loop over proteins.

* Fit a linear model for each protein with `lm()` and extract fitted parameters with `coef()`.

* Save results in a list.

* Combine the results into a data frame with `dplyr::bind_rows()`.

```{r}
# Approach 2
t_start <- proc.time()
list_allprot <- vector("list", length = length(prots))
for (i in seq_along(prots)) {
    oneprot <- twin_dia2 %>% filter(protein == prots[i])  # Subset for one protein
    fit <- lm(log2inty_l ~ 0 + run + feature, data = oneprot)  # Fit a linear model
    fit_coef <- coef(fit)  # Extract fitted parameters
    # Assemble the result in a data frame, and save to the list
    list_allprot[[i]] <- data_frame(
        protein = prots[i], 
        effect = names(fit_coef), 
        estimate = fit_coef
    ) %>% 
        filter(grepl("run", effect)) %>% 
        mutate(effect = gsub("run", "", effect))
}
df_allprot <- bind_rows(list_allprot)
(t2 <- proc.time() - t_start)
```

The approaches discussed so far have two obvious drawbacks: 

1. The fitted models are not saved - it requires re-fitting the models to extract additional (unplanned) summaries.

2. The output objects of models are not tidy - it requires additional efforts to extract and reformat (tidy) summaries of interest.


## General split-apply-combine approach with arbitrary operations

Improve the solution through the use of: 

* List-columns.

* Tidying methods for model objects in broom.


### `dplyr::group_by()` + `dplyr::do()`

We can save the fitted model for each protein in a new list-column: 

```{r}
fit_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    do(fit = lm(log2inty_l ~ 0 + run + feature, data = .))
fit_dia
```

`do()` requires explicit use of the `.`  placeholder, to indicate where the input gets passed on to operate, as in

```{r, eval=FALSE}
# When input is not the first argument of a function
FUN(Y, X)
X %>% FUN(Y, .)

FUN(Y, Z = X)
X %>% FUN(Y, Z = .)
```

https://jennybc.github.io/purrr-tutorial/pt00_gotchas.html


### broom

A library that turns model objects into data frames in tidy format with three tidying methods: 

* `broom::tidy()`: to extract parameter-level summaries.

* `broom::augment()`: to extract observation-level summaries.

* `broom::glance()`: to extract model-level summaries.

```{r}
library(broom)
?broom
```

Use broom to tidy output objects of models

```{r}
fit <- lm(log2inty_l ~ 0 + run + feature, data = sub_dia)

# Each row is a parameter
tidy(fit)

# Each row is an observation; columns from the fitted model start with .
head(augment(fit))

# One row for the model
glance(fit)
```


### Approach 3

* Define the analysis unit (protein, in this case) with `dplyr::group_by()`.

* Fit a linear model for each protein with `lm()`.

* Extract the estimates with `broom::tidy()` and `dplyr::do()` to summarize the information for each protein.


```{r}
# Approach 3
t_start <- proc.time()
twin_dia2 %>% 
    group_by(protein) %>%
    do(tidy(lm(log2inty_l ~ 0 + run + feature, data = .))) %>% 
    filter(grepl("run", term)) %>% 
    mutate(term = gsub("run", "", term))
t3 <- proc.time() - t_start
```

Note that multiple rows are generated within each model. 

Or, apply the tidying methods on the data frame `fit_data` with fitted models: 

```{r, eval=FALSE}
fit_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    do(fit = lm(log2inty_l ~ 0 + run + feature, data = .))

fit_dia %>% tidy(fit)
```


List-coulmns keep together related items in a data frame, thus allowing to perform operations in a data-structure-informed way. Their flexibility makes it convenient to carry out intermediate processes which may take different data structures or formats. However, they are generally hard to work with most R functions that are developed for atomic vectors or data frames. To work effectively with list-columns, we need to develope techniques to 

* Inspect their content.
* Compute with functions developed to work with lists.
* Simplify back to a data frame or atomic vector.


### Nested data frame

Use `tidyr::nest()` to create nested data frame: 

```{r}
nested_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    nest()
nested_dia
```

Nested data frame is an instance of list-columns. It organizes the data in a structurally-informative format: 

* One row per group.

* New `data` column to store the stratified data corresponding to each protein, in a list (list-column).

Inspect/extract data in the list with double brackets `[[]]`:

```{r}
# Data of protein A1AG_BOVINE
nested_dia$data[[1]]
```

```{r, eval=FALSE}
# Same as
nested_dia[[1, "data"]]
```

`unnest()` removes the nested structure of the nested data frame by repeating the regular columns once for each element of the list-column.

```{r}
nested_dia %>% unnest(data)
```

Library purrr provides a set of tools (map functions) to iterate over the list-columns with consistent syntax and return type, which makes it easy to compute with list-columns.


### The map functions of purrr

`map(X, FUN)` carries out the process: loop over a vector `X`, apply some operation `FUN()` to each element of `X`, and save the results as a list. 

`purrr::map()` is essentially `lapply()`

Reasons to use purrr

* Shortcuts facilitate anonymous functions for `FUN`

* Greater encouragement for type-safety
    + `map_chr()`
    + `map_dbl()`
    + `map_int()`
    + `map_lgl()`


```{r}
# For each protein, fit a linear model with purrr::map()
nested_dia <- nested_dia %>% 
    mutate(fit = map(data, ~ lm(log2inty_l ~ 0 + run + feature, data = .)))
nested_dia
```

```{r}
# For each fitted model, tidy output object with broom::tidy()
nested_dia <- nested_dia %>% 
    mutate(param = map(fit, tidy))
nested_dia
```

```{r}
head(nested_dia$param[[1]])
```

```{r}
nested_dia %>% 
    mutate(std = map_dbl(fit, sigma))
```


```{r}
# Unnest data back to the original form
nested_dia %>% unnest(param)
```


### Approach 4

* Create a nested data frame with `dplyr::group_by()` and `tidyr::nest()`.

* Fit a linear model for each protein with `lm()` and `purrr::map()`.

* Extract the estimates for each protein with `broom::tidy()` and `purrr::map()`.

* Transform back to the original form with `tidyr::unnest()`.

```{r}
# Approach 4
t_start <- proc.time()

# Create nested data frame 
nested_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    nest()
# Model and tidy output objects
nested_dia <- nested_dia %>% 
    mutate(
        fit = map(data, ~ lm(log2inty_l ~ 0 + run + feature, data = .)), 
        param = map(fit, tidy)
    )
# Unnest data and additional manipulation
nested_dia %>% unnest(param) %>% 
    filter(grepl("run", term)) %>% 
    mutate(term = gsub("run", "", term))
t4 <- proc.time() - t_start
```

A major advantage of Approach 4 is that it creates a very rich structured dataset that can be further explored in a principled way.

```{r}
rbind(t1, t2, t3, t4)
```


```{r}

nested_dia %>%
  mutate(rsq = map_dbl(fit, ~ summary(.x)[["r.squared"]])) %>%
  arrange(rsq)
```


## Reference

* Jenny Bryan's purrr tutorial: https://jennybc.github.io/purrr-tutorial/

* R for Data Science: 
    + http://r4ds.had.co.nz/iteration.html
    + http://r4ds.had.co.nz/many-models.html
