---
title: "Tidyverse - modeling"
author: "Advanced R"
date: "Thursday May 4, 2017"
output: html_document
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```


## Learning goal

Consistent workflow for both data wrangling and statistical modeling in the tidyverse.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
load("data/adv-R-twin.RData")
```


## Task

Model-based summary of feature log-intensities for all proteins in every run.

* Model the log-intensities of features for each protein considering feature and run as fixed effects.

* Run-level summarization with the fitted model.


## Approaches

We will discuss tools to perform modeling/testing in multiple groups through the use of: 

* Iterations.

* List-columns.


## Normalization

Same as in the previous section:

```{r}
twin_dia <- tbl_df(twin_dia) %>% 
    mutate(
        log2inty_h = log2(intensity_h), 
        log2inty_l = log2(intensity_l)
    )

med_dia <- twin_dia %>% 
    group_by(run) %>% 
    summarise(log2inty_med = median(log2inty_h, na.rm = TRUE)) %>% 
    mutate(log2inty_adj = median(log2inty_med) - log2inty_med)

twin_dia2 <- left_join(twin_dia, med_dia) %>% 
    mutate(
        log2inty_h = log2inty_h + log2inty_adj, 
        log2inty_l = log2inty_l + log2inty_adj, 
        intensity_h = 2 ^ log2inty_h,
        intensity_l = 2 ^ log2inty_l
    )

twin_dia2
```


## Use linear model to summarize feature log-intensities of a protein

Model feature log-intensities with fixed effects of run and feature:

```{r}
# One protein (AACT) measured in 3 runs (R001, R002, R003)
sub_dia <- twin_dia2 %>% 
    filter(protein == "AACT", run %in% c("R001", "R002", "R003"))

# Linear model with fixed effects of run and feature, no intercept
fit <- lm(log2inty_l ~ 0 + run + feature, data = sub_dia)
```


### Extract run effect from the linear model

```{r}
summary(fit)
```

```{r, eval=FALSE}
str(summary(fit))
```

```{r}
coef(fit)
coef(summary(fit))
```

```{r}
fit_coef <- coef(fit)

data_frame(effect = names(fit_coef), estimate = fit_coef) %>% 
    filter(grepl("run", effect)) %>% 
    mutate(effect = gsub("run", "", effect))
```


## Summarize for all proteins with a `for()` loop


### Approach 1

* Loop over proteins.

* Fit a linear model for each protein with `lm()` and extract relevant information.

* Add new results to previous ones in every iteration with `rbind()`.

```{r}
# Proteins in the dataset
prots <- unique(twin_dia2$protein)

# Approach 1
t_start <- proc.time()
df_allprot <- NULL
for (i in seq_along(prots)) {
    # Subset for one protein
    oneprot <- twin_dia2 %>% filter(protein == prots[i])
    # Fit linear model and extract estimates
    fit <- lm(log2inty_l ~ 0 + run + feature, data = oneprot)
    fit_coef <- coef(fit)
    # Assemble the result in a data frame
    df_oneprot <- data_frame(protein = prots[i], effect = names(fit_coef), estimate = fit_coef) %>% 
        filter(grepl("run", effect)) %>% 
        mutate(effect = gsub("run", "", effect))
    # Combine new result with those in previous iterations
    df_allprot <- rbind(df_allprot, df_oneprot)
}
(t1 <- proc.time() - t_start)
```

We should avoid this approach as it's not very efficient - in every iteration, R has to copy all the data from previous iterations.


### Approach 2

* Loop over proteins.

* Fit a linear model for each protein with `lm()` and extract relevant information.

* Save results in a list.

* Combine the results into a data frame with `dplyr::bind_rows()`.

```{r}
# Approach 2
t_start <- proc.time()
list_allprot <- vector("list", length = length(prots))
for (i in seq_along(prots)) {
    # Subset for one protein
    oneprot <- twin_dia2 %>% filter(protein == prots[i])
    # Fit linear model and extract estimates
    fit <- lm(log2inty_l ~ 0 + run + feature, data = oneprot)
    fit_coef <- coef(fit)
    # Assemble the result in a data frame, and save to the list
    list_allprot[[i]] <- data_frame(protein = prots[i], effect = names(fit_coef), estimate = fit_coef) %>%
        filter(grepl("run", effect)) %>% 
        mutate(effect = gsub("run", "", effect))
}
df_allprot <- bind_rows(list_allprot)
(t2 <- proc.time() - t_start)
```

The approaches discussed so far have two obvious limitations: 

1. The fitted models are not saved - it requires re-fitting the models to extract additional (unplanned) summaries.

2. The output objects of models are not tidy - it requires additional efforts to reformat the objects and extract summaries of our interest.


## General split-apply-combine approach with arbitrary operations

Better solution to avoid the limitations using: 

* List-columns.

* Tidying methods for model objects in broom.


### `group_by()` + `do()`

We can save the fitted model for each protein in a new list-column: 

```{r}
fit_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    do(fit = lm(log2inty_l ~ 0 + run + feature, data = .))
fit_dia
```

`.` is used as an argument placeholder, as in

```{r, eval=FALSE}
# When input is not the first argument of a function
FUN(Y, X)
X %>% FUN(Y, .)

FUN(Y, Z = X)
X %>% FUN(Y, Z = .)
```


### broom

A library that turns model objects into data frames in tidy format with three tidying methods: 

* Extract parameter-level summaries with `broom::tidy()`.

* Extract observation-level summaries with `broom::augment()`.

* Extract model-level summaries with `broom::glance()`.

```{r}
# install.packages("broom")
library(broom)
?broom
```

Use broom to tidy output objects of models

```{r}
fit <- lm(log2inty_l ~ 0 + run + feature, data = sub_dia)

# Each row is a coefficient
tidy(fit)

# Each row is an observation; new columns from the model start with .
head(augment(fit))

# One row for the model
glance(fit)
```


### Approach 3

* Define the analysis unit with `dplyr::group_by()`.

* Fit a linear model for each protein with `lm()`.

* Extract the estimates with `broom::tidy()` and `dplyr::do()` to summarize the information for each protein.


```{r}
# Approach 3
t_start <- proc.time()
twin_dia2 %>% 
    group_by(protein) %>%
    do(tidy(lm(log2inty_l ~ 0 + run + feature, data = .))) %>% 
    filter(grepl("run", term)) %>% 
    mutate(term = gsub("run", "", term))
t3 <- proc.time() - t_start
```
Note that multiple rows are generated within each model. 

Or, apply the tidying methods on the data frame `fit_data` with fitted models: 

```{r, eval=FALSE}
fit_dia %>% tidy(fit)
```


### Nested data frame

Use `tidyr::nest()` to create nested data frame for more general approaches.

* One row per group.

* New `data` column to store the stratified data, in a list (list-column).

```{r}
nested_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    nest()
nested_dia
```

Extract/assess data in the list with double brackets `[[]]`:

```{r}
# Data of protein A1AG_BOVINE
nested_dia$data[[1]]
```

```{r, eval=FALSE}
# Same as
nested_dia[[1, "data"]]
```

Nested data frame is an instance of list-columns. If we could easily manipulate/transform the list-columns, a consistent workflow can then be built natually. 

* Library purrr provides a set of tools for functional programming.

* Library broom provides tools to extract model-based summaries in a tidy format.


### The map functions of purrr

`map(X, FUN)` carries out the process: loop over a vector `X`, apply some operation `FUN()` to each element of `X`, and save the results as a list. 

```{r}
# For each protein, fit a linear model with purrr::map()
nested_dia <- nested_dia %>% 
    mutate(fit = map(data, ~ lm(log2inty_l ~ 0 + run + feature, data = .)))
nested_dia
```

```{r}
# For each fitted model, tidy output object with broom::tidy()
nested_dia <- nested_dia %>% 
    mutate(param = map(fit, tidy))
nested_dia
```

```{r}
head(nested_dia$param[[1]])
```

```{r}
# Unnest data back to the original form
nested_dia %>% unnest(param)
```


### Approach 4

* Create a nested data frame with `dplyr::group_by()` and `tidyr::nest()`.

* Fit a linear model for each protein with `lm()` and `purrr::map()`.

* Extract the estimates for each protein with `broom::tidy()` and `purrr::map()`.

* Transform back to the original form with `tidyr::unnest()`.

```{r}
# Approach 4
t_start <- proc.time()

# Create nested data frame 
nested_dia <- twin_dia2 %>% 
    group_by(protein) %>% 
    nest()
# Model and tidy output objects
nested_dia <- nested_dia %>% 
    mutate(
        fit = map(data, ~ lm(log2inty_l ~ 0 + run + feature, data = .)), 
        param = map(fit, tidy)
    )
# Unnest data and additional manipulation
nested_dia %>% unnest(param) %>% 
    filter(grepl("run", term)) %>% 
    mutate(term = gsub("run", "", term))
t4 <- proc.time() - t_start
```

A major advantage of Approach 4 is that it creates a very rich structured dataset that can be further explored in a principled way.

```{r}
rbind(t1, t2, t3, t4)
```

